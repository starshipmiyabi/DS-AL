<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>图的拓扑排序 (Topological Sort) 可视化教学</title>
  <style>
    body {
      font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
      background-color: #f0f2f5;
      display: flex;
      flex-direction: column;
      align-items: center;
      margin: 0;
      padding: 20px;
      height: 100vh;
      box-sizing: border-box;
    }

    h2 { color: #333; margin-bottom: 10px; }

    .controls {
      margin-bottom: 15px;
      display: flex;
      gap: 10px;
      align-items: center;
    }

    button {
      padding: 8px 18px;
      font-size: 15px;
      cursor: pointer;
      border: none;
      border-radius: 5px;
      transition: background 0.2s;
    }

    .btn-start { background-color: #673ab7; color: white; }
    .btn-start:hover { background-color: #5e35b1; }
    .btn-start:disabled { background-color: #ccc; cursor: not-allowed; }

    .btn-pause { background-color: #9E9E9E; color: white; }
    .btn-pause:hover { background-color: #757575; }
    .btn-pause:disabled { background-color: #ccc; cursor: not-allowed; }

    .btn-reset { background-color: #f44336; color: white; }
    .btn-reset:hover { background-color: #d32f2f; }

    .speed-control {
      display: flex;
      align-items: center;
      gap: 8px;
      font-size: 14px;
      color: #666;
    }

    .main-container {
      display: flex;
      gap: 20px;
      background: white;
      padding: 20px;
      border-radius: 12px;
      box-shadow: 0 4px 15px rgba(0,0,0,0.1);
    }

    .left-panel {
      display: flex;
      flex-direction: column;
      gap: 15px;
    }

    .graph-container {
      position: relative;
      width: 520px;
      height: 280px;
      border: 2px solid #eee;
      border-radius: 8px;
      background-color: #fafafa;
    }

    svg {
      position: absolute;
      inset: 0;
      width: 100%;
      height: 100%;
      z-index: 1;
    }

    line {
      stroke: #bbb;
      stroke-width: 2;
      marker-end: url(#arrow);
      transition: stroke 0.3s;
    }

    .node {
      position: absolute;
      width: 40px;
      height: 40px;
      border-radius: 50%;
      background-color: white;
      border: 2px solid #333;
      display: flex;
      justify-content: center;
      align-items: center;
      font-weight: bold;
      z-index: 2;
      transform: translate(-50%, -50%);
      transition: all 0.3s ease;
    }

    .node.active {
      background-color: #673ab7;
      color: #fff;
      border-color: #512da8;
      box-shadow: 0 0 15px rgba(103,58,183,0.7);
      transform: translate(-50%, -50%) scale(1.2);
    }

    .node.removed {
      background-color: #e0e0e0;
      border-color: #bdbdbd;
      color: #777;
      opacity: 0.7;
    }

    /* 零入度栈可视化 */
    .stack-container {
      width: 520px;
      height: 70px;
      background: #f5f5f5;
      border-radius: 8px;
      border: 2px solid #ccc;
      display: flex;
      align-items: center;
      padding: 0 15px;
      gap: 8px;
      position: relative;
      overflow-x: auto;
    }

    .stack-label {
      position: absolute;
      top: -22px;
      left: 0;
      font-size: 14px;
      font-weight: bold;
      color: #666;
    }

    .stack-item {
      width: 40px;
      height: 40px;
      border-radius: 4px;
      background: #ffca28;
      color: #333;
      display: flex;
      justify-content: center;
      align-items: center;
      font-weight: bold;
      flex-shrink: 0;
      box-shadow: 0 2px 5px rgba(0,0,0,0.2);
      animation: slideIn 0.25s ease;
    }

    @keyframes slideIn {
      from { transform: translateY(10px); opacity: 0; }
      to { transform: translateY(0); opacity: 1; }
    }

    /* 输出序列 */
    .output-container {
      width: 520px;
      min-height: 70px;
      background: #f5f5f5;
      border-radius: 8px;
      border: 2px dashed #673ab7;
      display: flex;
      align-items: center;
      padding: 10px 15px;
      gap: 8px;
      position: relative;
      flex-wrap: wrap;
    }

    .output-label {
      position: absolute;
      top: -22px;
      left: 0;
      font-size: 14px;
      font-weight: bold;
      color: #666;
    }

    .output-item {
      width: 40px;
      height: 40px;
      border-radius: 4px;
      background: #7e57c2;
      color: #fff;
      display: flex;
      justify-content: center;
      align-items: center;
      font-weight: bold;
      flex-shrink: 0;
      animation: slideIn 0.25s ease;
    }

    /* 日志区域 */
    .log-panel {
      width: 320px;
      height: 430px;
      overflow-y: auto;
      border: 1px solid #ddd;
      background: #1e1e1e;
      color: #0f0;
      padding: 10px;
      font-family: 'Courier New', Courier, monospace;
      font-size: 14px;
      border-radius: 8px;
    }

    .log-entry {
      margin-bottom: 5px;
      border-bottom: 1px solid #333;
      padding-bottom: 2px;
    }

    .deg-label {
      position: absolute;
      font-size: 12px;
      color: #555;
      transform: translate(-50%, 10px);
    }
  </style>
</head>
<body>
  <h2>图的拓扑排序 (Topological Sort) 可视化教学</h2>

  <div class="controls">
    <button class="btn-start" onclick="startTopo()">开始拓扑排序</button>
    <button class="btn-pause" onclick="togglePause()">暂停</button>
    <button class="btn-reset" onclick="resetAll()">重置</button>

    <div class="speed-control">
      <span>速度:</span>
      <input type="range" id="speedRange" min="200" max="2000" value="1000" step="100">
      <span id="speedVal">1.0秒</span>
    </div>
  </div>

  <div class="main-container">
    <div class="left-panel">
      <div class="graph-container" id="graphArea">
        <!-- 箭头定义 -->
        <svg id="svgLines">
          <defs>
            <marker id="arrow" markerWidth="10" markerHeight="10" refX="10" refY="3" orient="auto" markerUnits="strokeWidth">
              <path d="M0,0 L10,3 L0,6 z" fill="#bbb"></path>
            </marker>
          </defs>
        </svg>
      </div>

      <div class="stack-container" id="stackVis">
        <span class="stack-label">零入度顶点栈 (课件 7.5.1：存放入度为 0 的顶点)</span>
      </div>

      <div class="output-container" id="outputVis">
        <span class="output-label">拓扑有序序列 (Topological Order)</span>
      </div>
    </div>

    <div class="log-panel" id="logPanel">
      <div class="log-entry">&gt; 等待开始拓扑排序...</div>
    </div>
  </div>

  <script>
    // === 图数据：使用课件中 A,B,C,D 的经典 DAG 示例 ===
    // 对应 Ch07 图 2024.pdf 7.5.1 中 A→B, A→C, B→D, C→D 的有向无环图，
    // 拓扑序可以是 A B C D 或 A C B D。 [oai_citation:0‡Ch07 图 2024.pdf](sediment://file_00000000eb8871f4a33ea739a8f60680)
    const graphData = {
      'A': { x: 120, y: 80,  neighbors: ['B', 'C'] },
      'B': { x: 60,  y: 200, neighbors: ['D'] },
      'C': { x: 180, y: 200, neighbors: ['D'] },
      'D': { x: 120, y: 320, neighbors: [] }
    };

    const container = document.getElementById('graphArea');
    const stackVis  = document.getElementById('stackVis');
    const outputVis = document.getElementById('outputVis');
    const logPanel  = document.getElementById('logPanel');

    let isRunning = false;
    let isPaused  = false;

    // 入度表
    let inDegree = {};

    // === 初始化：画图、节点、入度标签 ===
    function initGraph() {
      // 清空图区域，只保留 svg 容器
      container.innerHTML = `
        <svg id="svgLines">
          <defs>
            <marker id="arrow" markerWidth="10" markerHeight="10" refX="10" refY="3" orient="auto" markerUnits="strokeWidth">
              <path d="M0,0 L10,3 L0,6 z" fill="#bbb"></path>
            </marker>
          </defs>
        </svg>
      `;
      const svg = document.getElementById('svgLines');

      // 初始化入度
      inDegree = {};
      Object.keys(graphData).forEach(v => inDegree[v] = 0);
      Object.keys(graphData).forEach(u => {
        graphData[u].neighbors.forEach(v => inDegree[v]++);
      });

      // 画边
      for (let u in graphData) {
        const from = graphData[u];
        from.neighbors.forEach(v => {
          const to = graphData[v];
          const line = document.createElementNS('http://www.w3.org/2000/svg', 'line');
          line.setAttribute('x1', from.x);
          line.setAttribute('y1', from.y);
          line.setAttribute('x2', to.x);
          line.setAttribute('y2', to.y);
          line.setAttribute('id', `edge-${u}-${v}`);
          svg.appendChild(line);
        });
      }

      // 画节点 + 入度标签
      for (let id in graphData) {
        const node = graphData[id];

        const div = document.createElement('div');
        div.className = 'node';
        div.id = `node-${id}`;
        div.textContent = id;
        div.style.left = node.x + 'px';
        div.style.top  = node.y + 'px';
        container.appendChild(div);

        const deg = document.createElement('div');
        deg.className = 'deg-label';
        deg.id = `deg-${id}`;
        deg.style.left = node.x + 'px';
        deg.style.top  = (node.y + 25) + 'px';
        deg.textContent = `in=${inDegree[id]}`;
        container.appendChild(deg);
      }

      // 清空栈和输出区（保留 label）
      stackVis.innerHTML = '<span class="stack-label">零入度顶点栈 (课件 7.5.1：存放入度为 0 的顶点)</span>';
      outputVis.innerHTML = '<span class="output-label">拓扑有序序列 (Topological Order)</span>';
    }

    // === 工具函数 ===
    const sleep = ms => new Promise(resolve => setTimeout(resolve, ms));
    const delay = () => parseInt(document.getElementById('speedRange').value, 10);

    document.getElementById('speedRange').oninput = function() {
      document.getElementById('speedVal').innerText = (this.value / 1000).toFixed(1) + '秒';
    };

    function log(msg, color) {
      const div = document.createElement('div');
      div.className = 'log-entry';
      if (color) div.style.color = color;
      div.innerHTML = '&gt; ' + msg;
      logPanel.appendChild(div);
      logPanel.scrollTop = logPanel.scrollHeight;
    }

    function updateDegLabel(v) {
      const label = document.getElementById(`deg-${v}`);
      if (label) label.textContent = `in=${inDegree[v]}`;
    }

    function updateStackVis(stack) {
      const label = stackVis.querySelector('.stack-label');
      stackVis.innerHTML = '';
      stackVis.appendChild(label);
      stack.forEach(v => {
        const div = document.createElement('div');
        div.className = 'stack-item';
        div.textContent = v;
        stackVis.appendChild(div);
      });
    }

    function appendOutput(v) {
      const label = outputVis.querySelector('.output-label');
      const items = Array.from(outputVis.children).filter(c => c !== label);
      // 只保留一次 label
      outputVis.innerHTML = '';
      outputVis.appendChild(label);
      items.forEach(it => outputVis.appendChild(it));

      const div = document.createElement('div');
      div.className = 'output-item';
      div.textContent = v;
      outputVis.appendChild(div);
    }

    async function waitIfPaused() {
      if (!isPaused) return;
      await new Promise(resolve => {
        const t = setInterval(() => {
          if (!isPaused) { clearInterval(t); resolve(); }
        }, 100);
      });
    }

    // === 核心：拓扑排序动画（零入度 + 栈） ===
    async function startTopo() {
      if (isRunning) return;
      isRunning = true;
      isPaused  = false;

      document.querySelector('.btn-start').disabled = true;
      const btnPause = document.querySelector('.btn-pause');
      if (btnPause) { btnPause.disabled = false; btnPause.innerText = '暂停'; }

      logPanel.innerHTML =
        '<div class="log-entry" style="color:#ffeb3b">--- 开始拓扑排序：零入度算法 (课件 7.5.1) ---</div>';

      // 初始化图和入度（防止之前修改残留）
      initGraph();

      // 1. 统计入度已经在 initGraph 做完，这里只是解释
      log('已根据有向图统计各顶点入度 in[v]，对应课件中 StatInDegree(g, inDegree);', '#ccc');
      await sleep(delay());

      // 2. 建立入度为 0 的顶点栈（可视化为从左到右，右侧为栈顶）
      const stack = [];
      Object.keys(graphData).forEach(v => {
        if (inDegree[v] === 0) {
          stack.push(v);
          log(`顶点 ${v} 的入度为 0，将 ${v} 压入栈 (Push)`, '#90caf9');
        }
      });
      updateStackVis(stack);
      await sleep(delay());

      const topoResult = [];
      const totalV = Object.keys(graphData).length;

      // 3. 栈非空时重复：
      while (stack.length > 0) {
        await waitIfPaused();

        // ① 取出一个入度为 0 的顶点并输出之 —— Pop
        const v = stack.pop();
        updateStackVis(stack);

        const nodeEl = document.getElementById(`node-${v}`);
        nodeEl.classList.add('active');
        log(`栈顶顶点 ${v} 出栈 (Pop)，输出到拓扑序列`, '#ffcc80');
        appendOutput(v);
        topoResult.push(v);

        await sleep(delay());

        // ② “删除 v 以及以它为起点的边” ≡ 所有邻接点入度减 1
        const neighbors = graphData[v].neighbors;
        if (neighbors.length === 0) {
          log(`顶点 ${v} 没有后继顶点，无需修改任何入度。`);
        } else {
          for (let w of neighbors) {
            await waitIfPaused();
            inDegree[w]--;
            updateDegLabel(w);
            log(`删除边 <span style="color:#fff">${v}→${w}</span>，使 in[${w}]--，现在 in[${w}] = ${inDegree[w]}`);
            await sleep(delay() / 1.5);

            // ③ 如果某邻接点入度减为 0，将其压入栈
            if (inDegree[w] === 0) {
              stack.push(w);
              updateStackVis(stack);
              log(
                `顶点 ${w} 的入度减为 0，满足“无前驱顶点”条件，将 ${w} 压入零入度栈 (Push)`,
                '#81c784'
              );
              await sleep(delay() / 1.5);
            }
          }
        }

        // 节点标记为“已删除”
        nodeEl.classList.remove('active');
        nodeEl.classList.add('removed');
        await sleep(delay() / 1.5);
      }

      // 4. 检查输出顶点个数是否等于顶点总数
      if (topoResult.length < totalV) {
        log(
          `输出顶点个数 ${topoResult.length} &lt; 顶点总数 ${totalV}，根据课件结论：图中存在有向环，拓扑排序失败。`,
          '#ff5252'
        );
      } else {
        log(
          `栈已空且输出了所有 ${totalV} 个顶点，得到一个拓扑有序序列：<span style="color:#ffeb3b;font-weight:bold">${topoResult.join(' ')}</span>`,
          '#c5e1a5'
        );
        log('这与课件中示例 A B C D / A C B D 属于同一类拓扑序列。', '#c5e1a5');
      }

      isRunning = false;
      isPaused  = false;
      document.querySelector('.btn-start').disabled = false;
      if (btnPause) btnPause.disabled = true;
    }

    // === 控制函数 ===
    function togglePause() {
      if (!isRunning) return;
      isPaused = !isPaused;
      const btnPause = document.querySelector('.btn-pause');
      if (isPaused) {
        if (btnPause) btnPause.textContent = '恢复';
        log('算法已暂停：当前顶点/入度更新过程在这里等待，对应“栈暂不 Pop、新顶点暂不 Push”的状态。', '#fff');
      } else {
        if (btnPause) btnPause.textContent = '暂停';
        log('算法继续运行：继续从零入度栈中 Pop 顶点并更新其后继顶点入度。', '#fff');
      }
    }

    function resetAll() {
      if (isRunning) return;
      isRunning = false;
      isPaused  = false;
      logPanel.innerHTML = '<div class="log-entry">&gt; 已重置拓扑排序演示</div>';
      initGraph();
      const btnStart = document.querySelector('.btn-start');
      if (btnStart) btnStart.disabled = false;
      const btnPause = document.querySelector('.btn-pause');
      if (btnPause) {
        btnPause.disabled = true;
        btnPause.textContent = '暂停';
      }
    }

    // 初始渲染
    initGraph();
    // 默认暂停按钮不可用
    (function() {
      const btnPause = document.querySelector('.btn-pause');
      if (btnPause) btnPause.disabled = true;
    })();
  </script>
</body>
</html>